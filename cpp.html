<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<title>C++</title>
	<link href="style.css" rel="stylesheet" type="text/css">
</head>
<body>
<script src="menu.js"></script>
<div class="text">


<m>[C++] ITERATOR</m>
<b>iterator</b> - структура данных, которая используется для обращения к определенному элементу в контейнерах STL
Итератор должен быть такого же типа как и контейнер, на который он ссылается
#include &lt;iterator&gt;	//подключить заголовочный файл &lt;iterator&gt;
<b>Объявление Iterator</b>
vector&lt;int&gt;::iterator It				//объявить итератор
vector&lt;int&gt;::const_iterator It			//объявить итератор без доступа к изменению значений
vector&lt;int&gt;::iterator It = V.begin()	//объявить итератор и инициализировать итератором начала вектора
<b>Действия Iterator</b>
It += N						//сместить итератор на N элементов вправо (недоступно для типов list, set, map)
advance(It, N)				//сместить итератор на N элементов вправо
It++						//сместить итератор на один элемент вправо
It--						//сместить итератор на один элемент влево
It1 == It2 || It1 != It2	//сравнить два итератора (операции &lt;&gt; недоступны для типов list, set, map)
cout &lt;&lt; *It					//вывести значение элемента с позицией It
*It += N					//прибавить N к значению элемента с позицией It
int Diff = It1 - It2		//передать переменной разницу итераторов
auto It = V.begin()			//эквивалент: vector&lt;int&gt;::iterator It = V.begin();




<m>[C++] STRING</m>
<b>string</b> - класс с методами и переменными для организации работы со строками
#include &lt;string&gt;	//подключить заголовочный файл &lt;string&gt;
<b>Объявление String</b>
string Str			//объявить строку
string Str = "text"	//объявить и инициализировать строку
<b>Ввод и Вывод String</b>
cin &gt;&gt; Str			//ввести строку до пробела или каретки
getline(cin, Str)	//ввести всю строку
cout &lt;&lt; Str			//вывести строку
<b>Арифметические Операции String</b>
=				//присвоить значение одной строки другой
+=				//добавить в конец строки другую строку
+				//конкатенировать две строки
==; !=			//сравнить две строки посимвольно
&lt;; &gt;; &lt;=; &gt;=	//сравнить две строки лексикографически
Str[0]			//обратиться к первому символу строки
<b>Методы String</b>
Str.push_back(Sign)						//добавить символ
Str.size()								//вернуть размер
Str.length()							//вернуть размер
Str.resize(N)							//изменить размер
Str.resize(N, Sign)						//изменить размер, изменяя новые символы
Str.clear()								//очистить
Str.empty()								//true, если пуст
Str.begin()								//вернуть итератор начала
Str.end()								//вернуть итератор конца
Str.insert(Pos, N, Sign)				//вставить в позицию символ N раз
Str1.insert(Pos, Str2)					//вставить в позицию строку
Str1.insert(Pos1, Str2, Pos2, N)		//вставить в позицию строку от Pos N символов
Str.insert(It, Sign)					//вставить в итератор символ
Str.insert(It, N, Sign)					//вставить в итератор символ N раз
Str.insert(It1, It2, It3)				//вставить в итератор символы из диапазона
Str.append(N, Sign)						//добавить символ N раз
Str1.append(Str2)						//добавить строку
Str1.append(Str2, Pos, N)				//добавить строку от Pos N символов
Str.replace(Pos, N1, N2, Sign)			//удалить от Pos N1 символов и вставить символ N2 раз
Str1.replace(Pos, N, Str2)				//удалить от Pos N символов и вставить строку
Str1.replace(Pos1, N1, Str2, Pos2, N2)	//удалить от Pos1 N1 символов и вставить строку от Pos2 N2 символов
Str.erase(Pos)							//удалить символы с позиции
Str.erase(Pos, N)						//удалить символы с позиции N раз
Str.erase(It)							//удалить символ с итератора
Str.erase(It1, It2)						//удалить символы из диапазона итераторов
Str.substr(Pos)							//вернуть подстроку с позиции
Str.substr(Pos, N)						//вернуть подстроку с позиции N символов
Str1.swap(Str2)							//обменять значения
Str1.find(Str2)							//вернуть позицию встречи строки
Str1.find(Str2, Pos)					//вернуть позицию встречи строки поиск от Pos
Str1.find(Str2, Pos, N)					//вернуть позицию встречи N символов строки поиск от Pos
Str1.rfind(Str2)						//вернуть позицию встречи строки поиск справа
Str1.rfind(Str2, Pos)					//вернуть позицию встречи строки поиск от Pos справа
Str1.rfind(Str2, Pos, N)				//вернуть позицию встречи N символов строки поиск от Pos справа
Str1.find_first_of(Str2)				//вернуть позицию встречи символа из строки
Str1.find_first_of(Str2, Pos)			//вернуть позицию встречи символа из строки поиск от Pos
Str1.find_last_of(Str2)					//вернуть позицию встречи символа из строки поиск справа
Str1.find_last_of(Str2, Pos)			//вернуть позицию встречи символа из строки поиск от Pos справа
Str1.find_first_not_of(Str2)			//вернуть позицию встречи символа не из строки
Str1.find_first_not_of(Str2, Pos)		//вернуть позицию встречи символа не из строки поиск от Pos
Str1.find_last_not_of(Str2)				//вернуть позицию встречи символа не из строки поиск справа
Str1.find_last_not_of(Str2, Pos)		//вернуть позицию встречи символа не из строки поиск от Pos справа
Str.c_str()								//вернуть строку как указатель типа char*




<m>[C++] VECTOR</m>
<b>vector</b> - структура данных, которая уже является моделью динамического массива
#include &lt;vector&gt;	//подключить заголовочный файл &lt;vector&gt;
<b>Объявление Vector</b>
vector&lt;int&gt; V								//объявить вектор
vector&lt;int&gt; V(N)							//объявить нулевой вектор размером N
vector&lt;int&gt; V(N, Value)						//объявить вектор размером N со значениями Value
vector&lt;vector&lt;int&gt;&gt; V						//объявить двумерный вектор
vector&lt;vector&lt;int&gt;&gt; V(N, vector&lt;int&gt;(M))	//выделить память двумерному вектору размером N*M
<b>Арифметические Операции Vector</b>
=				//присвоить значение одного вектора другому
==; !=			//сравнить два вектора поэлементно
&lt;; &gt;; &lt;=; &gt;=	//сравнить два вектора лексикографически
V[0]			//обратиться к первому элементу вектора
V[0][0]			//обратиться к первому элементу двумерного вектора
<b>Методы Vector</b>
V.at(I)					//обратиться к I-му элементу с генерацией исключения
V.front()				//вернуть первый элемент
V.back()				//вернуть последний элемент
V.push_back(Value)		//добавить элемент
V.emplace_back(Value)	//добавить элемент
V.pop_back()			//удалить последний элемент
V.size()				//вернуть размер
V.resize(N)				//изменить размер
V.resize(N, Value)		//изменить размер, изменяя новые элементы
V.clear()				//очистить
V.empty()				//true, если пуст
V.reserve(Byte)			//зарезервировать объем памяти
V.capacity()			//вернуть объем памяти
V.shrink_to_fit()		//освободить память
V.begin()				//вернуть итератор начала
V.end()					//вернуть итератор конца
V.insert(It, Value)		//вставить в итератор элемент
V.insert(It, N, Value)	//вставить в итератор элемент N раз
V.insert(It1, It2, It3)	//вставить в итератор элементы из диапазона итераторов
V.erase(It)				//удалить элемент с итератора
V.erase(It1, It2)		//удалить элементы из диапазона итераторов
V1.swap(V2)				//обменять значения




<m>[C++] LIST</m>
<b>list</b> - структура данных, каждый элемент списка знает только о предыдущем и о следующем элементах
#include &lt;list&gt;	//подключить заголовочный файл &lt;list&gt;
<b>Объявление List</b>
list&lt;int&gt; L				//объявить список
list&lt;int&gt; L(N)			//объявить нулевой список размером N
list&lt;int&gt; L(N, Value)	//объявить список размером N со значениями Value
<b>Арифметические Операции List</b>
=				//присвоить значение одного списка другому
==; !=			//сравнить два списка поэлементно
&lt;; &gt;; &lt;=; &gt;=	//сравнить два списка лексикографически
У двусвязного списка отсутсвуют индексы, вместо них используются итераторы
<b>Методы List</b>
L.front()				//вернуть первый элемент
L.back()				//вернуть последний элемент
L.push_front(Value)		//добавить элемент в начало
L.push_back(Value)		//добавить элемент в конец
L.pop_front()			//удалить первый элемент
L.pop_back()			//удалить последний элемент
L.size()				//вернуть размер
L.clear()				//очистить
L.empty()				//true, если пуст
L.begin()				//вернуть итератор начала
L.end()					//вернуть итератор конца
L.insert(It, Value)		//вставить в итератор элемент
L.insert(It, N, Value)	//вставить в итератор элемент N раз
L1.merge(L2)			//добавить список
L.erase(It)				//удалить элемент с итератора
L.erase(It1, It2)		//удалить элементы из диапазона итераторов
L.remove(Value)			//удалить элементы со значением
L.remove_if(Condition)	//удалить элементы с условием
L.unique()				//удалить повторяющиеся элементы
L1.swap(L2)				//обменять значения




<m>[C++] STACK</m>
<b>stack</b> - структура данных, в которой доступ осуществляется только к последнему добавленному элементу
#include &lt;stack&gt;	//подключить заголовочный файл &lt;stack&gt;
<b>Объявление Stack</b>
stack&lt;int&gt; St				//объявить стек (по умолчанию на основе deque)
stack&lt;int, vector&lt;int&gt;&gt; St	//объявить стек на основе vector
<b>Арифметические Операции Stack</b>
=				//присвоить значение одного стека другому
==; !=			//сравнить два стека поэлементно
&lt;; &gt;; &lt;=; &gt;=	//сравнить два стека лексикографически
Стек не работает с итераторами
<b>Методы Stack</b>
St.peek(I)			//обратиться к I-му элементу стека от вершины
St.top()			//вернуть верхний элемент стека
St.push(Value)		//добавить элемент
St.emplace(Value)	//добавить элемент
St.pop()			//удалить элемент
St.size()			//вернуть размер
St.empty()			//true, если пуст
St1.swap(St2)		//обменять значения




<m>[C++] QUEUE</m>
<b>queue</b> - структура данных, в которой доступ осуществляется только к самому раннее добавленому элементу
Новые элементы добавляются в конец очереди, а удаляются из начала очереди
#include &lt;queue&gt;	//подключить заголовочный файл &lt;queue&gt;
<b>Объявление Queue</b>
queue&lt;int&gt; Qu				//объявить очередь (по умолчанию на основе deque)
queue&lt;int, list&lt;int&gt;&gt; Qu	//объявить очередь на основе list
<b>Арифметические Операции Queue</b>
=				//присвоить значение одной очереди другой
==; !=			//сравнить две очереди поэлементно
&lt;; &gt;; &lt;=; &gt;=	//сравнить две очереди лексикографически
<b>Методы Queue</b>
Qu.front()			//вернуть первый элемент
Qu.back()			//вернуть последний элемент
Qu.push(Value)		//добавить элемент в конец очереди
Qu.emplace(Value)	//добавить элемент в конец очереди
Qu.pop()			//удалить первый элемент
Qu.size()			//вернуть размер
Qu.empty()			//true, если пуст
Qu.swap()			//обменять значения




<m>[C++] DEQUE</m>
<b>deque</b> - структура данных, позволяющая добавлять элементы в конец и в начало, удалять элементы из конца и из начала
#include &lt;deque&gt;	//подключить заголовочный файл &lt;deque&gt;
<b>Объявление Deque</b>
deque&lt;int&gt; Dq							//объявить дек
deque&lt;int&gt; Dq(N)						//объявить нулевой дек размером N
deque&lt;int&gt; Dq(N, Value)					//объявить дек размером N со значениями Value
deque&lt;deque&lt;int&gt;&gt; Dq					//объявить двумерный дек
deque&lt;deque&lt;int&gt;&gt; Dq(N, deque&lt;int&gt;(M))	//выделить память двумерному деку размером N*M
<b>Арифметические Операции Deque</b>
=				//присвоить значение одного дека другому
==; !=			//сравнить два дека поэлементно
&lt;; &gt;; &lt;=; &gt;=	//сравнить два дека лексикографически
Dq[0]			//обратиться к первому элементу дека
Dq[0][0]		//обратиться к первому элементу двумерного дека
<b>Методы Deque</b>
Dq.at(I)					//обратиться к I-му элементу с генерацией исключения
Dq.front()					//вернуть первый элемент
Dq.back()					//вернуть последний элемент
Dq.push_front(Value)		//добавить элемент в начало
Dq.push_back(Value)			//добавить элемент в конец
Dq.emplace_front(Value)		//добавить элемент в начало
Dq.emplace_back(Value)		//добавить элемент в конец
Dq.pop_front()				//удалить первый элемент
Dq.pop_back()				//удалить последний элемент
Dq.size()					//вернуть размер
Dq.resize(N)				//изменить размер
Dq.resize(N, Value)			//изменить размер, изменяя новые элементы
Dq.clear()					//очистить
Dq.empty()					//true, если пуст
Dq.begin()					//вернуть итератор начала
Dq.end()					//вернуть итератор конца
Dq.insert(It, Value)		//вставить в итератор элемент
Dq.insert(It, N, Value)		//вставить в итератор элемент N раз
Dq.insert(It1, It2, It3)	//вставить в итератор элементы из диапазона итераторов
Dq.erase(It)				//удалить элемент с итератора
Dq.erase(It1, It2)			//удалить элементы из диапазона итераторов
Dq1.swap(Dq2)				//обменять значения




<m>[C++] SET / MULTISET</m>
<b>set</b> - структура данных, хранящая все элементы в порядке возрастания без повторяющихся значений
<b>multiset</b> - структура данных, хранящая все элементы в порядке возрастания с возможностью повторения значений
#include &lt;set&gt;	//подключить заголовочный файл &lt;set&gt;
<b>Объявление Set</b>
set&lt;int&gt; S			//объявить множество
multiset&lt;int&gt; MS	//объявить мультимножество
<b>Арифметические Операции Set</b>
=				//присвоить значение одного множества другому
==; !=			//сравнить два множества поэлементно
&lt;; &gt;; &lt;=; &gt;=	//сравнить два множества лексикографически
<b>Методы Set</b>
S.size()				//вернуть размер
S.clear()				//очистить
S.empty()				//true, если пуст
S.begin()				//вернуть итератор начала
S.end()					//вернуть итератор конца
S.insert(Value)			//вставить элемент
S.insert(It, Value)		//вставить в итератор элемент
S.insert(It1, It2)		//вставить в итератор элементы из диапазона итераторов
S.erase(Value)			//удалить элемент
S.erase(It)				//удалить элемент с итератора
S.erase(It1, It2)		//удалить элементы из диапазона итераторов
S1.swap(S2)				//обменять значения
S.count(Value)			//вернуть количество элементов
S.find(Value)			//вернуть итератор встречи элемента
S.lower_bound(Value)	//вернуть итератор встречи элемента большее или равное значению
S.upper_bound(Value)	//вернуть итератор встречи элемента большее значению




<m>[C++] MAP / MULTIMAP</m>
<b>map</b> - ассоциативный контейнер, который работает по принципу - [ключ - значение] без повторяющихся ключей
<b>multimap</b> - ассоциативный контейнер, который работает по принципу - [ключ - значение] с возможностью повтора ключей
#include &lt;map&gt;	//подключить заголовочный файл &lt;map&gt;
<b>Объявление Map</b>
map&lt;int, string&gt; M			//объявить словарь
multimap&lt;int, string&gt; MM	//объявить мультисловарь
<b>Арифметические Операции Map</b>
=				//присвоить значение одного словаря другому
==; !=			//сравнить два словаря поэлементно
&lt;; &gt;; &lt;=; &gt;=	//сравнить два словаря лексикографически
M[0] = "text"	//присвоить значение по ключу
Если обратиться к несуществующему ключу и присвоить ему значение, то в словаре добавится новая пара
M[0].First	//обратиться к ключу
It-&gt;First	//обратиться к ключу через итератор
M[0].Second	//обратиться к значению
It-&gt;Second	//обратиться к значению через итератор
Невозможно изменить значение ключа при обращении через итератор It-&gt;First
<b>Методы Map</b>
M.at(I)									//обратиться к I-му элементу с генерацией исключения
M.size()								//вернуть размер
M.clear()								//очистить
M.empty()								//true, если пуст
M.begin()								//вернуть итератор начала
M.end()									//вернуть итератор конца
M.emplace(Key, Value)					//добавить элемент
M.insert(make_pair(Key, Value))			//вставить элемент
M.insert(pair&lt;int, int&gt;(Key, Value))	//вставить элемент
M.insert(It, make_pair(Key, Value))		//вставить в итератор элемент
M.insert(It1, It2)						//вставить элементы из диапазона итераторов
M.erase(Key)							//удалить элемент
M.erase(It)								//удалить элемент с итератора
M.erase(It1, It2)						//удалить элементы из диапазона итераторов
M1.swap(M2)								//обменять значения
M.count(Key)							//вернуть количество элементов
M.find(Key)								//вернуть итератор встречи элемента
M.lower_bourd(Key)						//вернуть итератор встречи элемента большее или равное ключу
M.upper_bound(Key)						//вернуть итератор встречи элемента большее ключу




<m>[C++] ALGORITHM / LAMBDA</m>
#include &lt;algorithm&gt;	//подключить заголовочный файл &lt;algorithm&gt;
+inserter - возможность вставить элементы через методы:
1) inserter(Container, It)
2) front_inserter(Container)
3) back_inserter(Container)
<b>Condition</b>
Condition - булевская или анонимная функция (например, [](int El){return El = 0;})
В параметры передается только имя булевской функции []
<b>Методы Algorithm</b>
copy(It1, It2, It3)					//копировать элементы (+inserter)
copy_if(It1, It2, It3, Condition)	//копировать элементы с условием (+inserter)
move(It1, It2, It3)					//вставить элементы с замещением (+inserter)
remove(It1, It2, Value)				//убрать элементы за возвращаемый итератор
remove_if(It1, It2, Condition)		//убрать элементы за возвращаемый итератор c условием
unique(It1, It2)					//убрать неуникальные элементы за возвращаемый итератор
unique_copy(It1, It2, It3)			//копировать уникальные элементы (+inserter)
min_element(It1, It2)				//вернуть минимальный элемент
max_element(It1, It2)				//вернуть максимальный элемент
minmax_element(It1, It2)			//вернуть пару из минимального и максимального элемента
count(It1, It2, Value)				//вернуть кольчество элементов
count_if(It1, It2, Condition)		//вернуть количество элементов с условием
equal(It1, It2, It3, It4)			//true, если диапазоны итераторов содержат одинаковые элементы
sort(It1, It2)						//сортировать элементы по возрастанию
random_shuffle(It1, It2)			//переставить элементы в случайном порядке
rotate(It1, It1 + N, It2)			//сместить элементы на N
rotate_copy(It1, It1 + N, It2, It3)	//сместить элементы на N с копированием (+inserter)
reverse(It1, It2)					//развернуть элементы в обратном порядке
binary_search(It1, It2, Value)		//true, если элемент присутствует (контейнер упорядочен)
find(It1, It2, Value)				//вернуть итератор встречи элемента
find_if(It1, It2, Condition)		//вернуть итератор встречи элемента по условию
lower_bound(It1, It2, Value)		//вернуть итератор встречи элемента большее или равное значению
upper_bound(It1, It2, Value)		//вернуть итератор встречи элемента большее значению
<b>Лямбда функция</b> - безымянная локальная функция, которую можно создавать прямо внутри какого-либо выражения
<b>Объявление анонимной функции</b>
[]() {};
Где:
[]					//список внешних захватываемых объектов
()					//параметры анонимной функции
{}					//тело анонимной функции
auto F = []() {};	//присвоить переменной класс лямбда [тип переменной зависит от возвращаемого значения]
[]()->int {};		//жесткое указание типа возвращаемого значения
[&X, &Y]			//передача внешних параметров по ссылке
[=]					//передача всех внешних параметров по значению [нельзя изменять в теле лямбды]
[=]()mutable		//передача всех внешних параметров по значению [можно изменять только в теле лямбды]
[&]					//передача всех внешних параметров по ссылке
[this]				//передача полей и методов класса




<m>[C++] WSTRING / RUS</m>
<b>wstring</b> - структура данных "широких" локализованных символов, интернациональная кодировка символами Unicode
<b>Действия Wstring</b>
setlocale(LC_ALL, ".866")	//добавить кодировку с русскими символами
wstring Wstr = L"текст"		//объявить и инициализировать широкую строку
wcin &gt;&gt; Wstr				//ввести широкую строку
wcout &lt;&lt; Wstr				//вывести широкую строку
wcout &lt;&lt; L"текст"			//вывести русский текст
<b>Считать с Файла "file.txt" Строку с русским Текстом</b>
wstring Buff;
wifstream Fin("file.txt");
Fin.imbue(locale("Russian"));
getline(Fin, Buff);




<m>[C++] BINARY FILES</m>
При записи информации в двоичный файл символы и числа записываются в виде последовательности байт
#include &lt;fstream&gt;	//подключить заголовочный файл &lt;fstream&gt;
<b>Действия Fstream</b>
FILE *File								//объявить файловую переменную
fopen_s(&File, FileName, Mode)			//открыть файл в режиме
fread(&Value, sizeof(int), 1, File)		//считать sizeof() байт в переменную
fread(Arr, sizeof(int), N, File)		//считать sizeof()*N байт в массив
fwrite(&Value, sizeof(int), 1, File)	//записать sizeof() байт в переменную
fwrite(Arr, sizeof(int), N, File)		//записать sizeof()*N байт в массив
fseek(File, sizeof(int) * N, SEEK)		//переместить указатель файла к заданному байту
feof(File)								//true, если достигнут конец файла
fclose(File)							//закрыть файл
rename(FileName1, FileName2)			//переименовать файл
remove(FileName)						//удалить файл
<b>Режим Работы</b>
"rb"	//открыть в режиме чтения
"wb"	//создать для записи; файл очищается
"ab"	//создать/открыть для дозаписи в конец файла
"rb+"	//открыть в режиме чтения и записи
"wb+"	//открыть в режиме чтения и записи; файл очищается
"ab+"	//создать/открыть для исправления и дозаписи в конец файла
<b>Значение Смещения</b>
SEEK_SET	//с начала файла
SEEK_CUR	//с текущей позиции
SEEK_END	//с конца файла




<m>[C++] AUTO_PTR / UNIQUE_PTR / SHARED_PTR</m>
<b>auto_ptr</b> - умный указатель, затирает память указателя, который указывает на ту же область данных [затирается предыдущий]
auto_ptr&lt;int&gt; AP1(new int(5));
auto_ptr&lt;int&gt; AP2(AP1);			//ap1 стерся; ap2 = 5
<b>unique_ptr</b> - уникальный указатель, запрещена возможность одного указателя ссылаться на область другого указателя
unique_ptr&lt;int&gt; UP1(new int(5));
unique_ptr&lt;int&gt; UP2(UP1);			//недопускается компилятором [возможно: up2 = move(up1); up2.swap(up1)]
UP1.get();		//вернуть сырой указатель [raw pointer - *ptr]
UP1.reset();	//затереть данные указателя
UP1.release();	//сохранить данные; освободить их взаимосвязь с указателем
<b>shared_ptr</b> - владение указателями одним и тем же объектом в памяти [данные уничтожатся, когда униктожен последний указатель]




<m>[C++] TUPLE</m>
tuple&lt;int, double, wstring&gt; t1(1, 1.1, L"");					//инициализация tuple()
tuple&lt;int, double, wstring&gt; t2 = make_tuple(2, 2.1, L"text2");	//инициализация make_tuple() (operator=)
get&lt;2&gt;(t1) = L"text1";											//get&lt;&gt;() = value
wcout &lt;&lt; get&lt;0&gt;(t1) &lt;&lt; "\n";
wcout &lt;&lt; get&lt;1&gt;(t1) &lt;&lt; "\n";
wcout &lt;&lt; get&lt;2&gt;(t1) &lt;&lt; "\n";									//get&lt;&gt;()
wcout &lt;&lt; tuple_size&lt;decltype(t1)&gt;::value &lt;&lt; "\n";				//вернуть размер (tuple_size = 3)
t1.swap(t2);													//swap()
<b>//tie()</b>
int i_val;
double d_val;
wstring wstr_val;
tie(i_val, d_val, wstr_val) = t1;								//i_val = 1; d_val = 1.1; wstr_val = "text1"
tie(i_val, ignore, wstr_val) = t2;								//i_val = 2; d_val = 2.1; wstr_val = "text2"
<b>//tuple_cat()</b>
auto t3 = tuple_cat(t1, t2, t1);								//объединить кортежи (tuple_size = 9)
<b>//operator's</b>
wcout &lt;&lt; (t1 == t2) &lt;&lt; "\n";									//operator==
wcout &lt;&lt; (t1 != t2) &lt;&lt; "\n";									//operator!=




<m>[C++] МНОГОМОДУЛЬНЫЕ ПРОЕКТЫ</m>
<b>//код файла "%CLASSNAME.H%"</b>
#pragma once
#include &lt;iostream&gt;
using namespace std;
void Func1(int A);
void Func2(int A);
<b>//код файла "%CLASSNAME.CPP%"</b>
#include "%CLASSNAME.H%"
void Func1(int A) {...}
void Func2(int A) {...}
<b>//код файла "%MAIN.CPP%"</b>
#include "%CLASSNAME.H%"
int main {...}




<m>[C++] NAMESPACE</m>
namespace NameSpace {}		//объявить пространство имен
NameSpace::Func();			//использовать функцию описанную в пространстве имен
using namespace NameSpace;	//позволить использовать аттрибуты пространства имен без указания ::
Внутри пространства имен также можно объявить пространство имен, доступ к нему осуществляется через ::




<m>[C++] ENUM</m>
<b>enum</b> - перечисление логически связанных констант
enum State
{
	OFF,	// = 0
	ON		// = 1
};
<b>или</b>
enum State
{
	State1 = -1,
	State2 = 0,
	State3 = 1
};
State _State = State::OFF;	//объявление и инициализация переменной типа enum
По умолчанию перечисление начинается с 0
Последующее неприсвоенное перечисление на 1 больше предыдущего перечисления




<m>[C++] THREAD</m>
#include &lt;thread&gt;									//подключить заголовочный файл &lt;thread&gt;
this_thread::get_id();								//вернуть идентификатор текущего потока
this_thread::sleep_for(chrono::milliseconds(1000));	//остановить работу текущего потока на определенное время
<b>Методы Thread</b>
thread Th(Func);				//конструктор потока [принимает имя функции; выполняется параллельно]
thread Th(Func, A, B);			//конструктор потока [поток с параметрами; выполняется параллельно]
thread Th(this-&gt;Func);			//конструктор потока [вызов другого метода этого же класса; выполняется параллельно]
thread Th(&MyClass::Func, &MC);	//конструктор потока [или thread th([&mc]() {mc.func();}); &mc - изменять объект класса myclass]
Th.join();						//дождаться завершение потока [вызывать в момент, где нужно дождаться выполнения этого потока]
Th.detach();					//разорвать связь между объектом th и потоком [программа не станет дожидаться завершения потока]




<m>[C++] MUTEX / LOCK_GUARD / UNIQUE_LOCK</m>
time_point&lt;steady_clock&gt; TP = high_resolution_clock::now();	//инициализировать текущее время на этом этапе кода при выполнении
duration&lt;float&gt; Duration = TP2 - TP1;						//инициализировать разницу во времени между tp1 и tp2
Duration.count();											//вернуть время в секундах
<b>mutex</b> - не разрешает остальным потокам обращаться к ресурсу и работать с ним, если этот ресурс уже занят другим потоком
#include &lt;mutex&gt;						//подключить заголовочный файл &lt;mutex&gt;
mutex Mtx;								//объявить mutex
Mtx.lock();								//разрешить доступ к участку кода только по одному потоку
Mtx.unlock();							//разрешить доступ к участку кода для всех потоков
lock_guard&lt;mutex&gt; LG(Mtx);				//объявить lock_guard; разр доступ к участ кода только по одному потоку [до } или return]
unique_lock&lt;mutex&gt; UL(Mtx);				//объявить unique_lock; в конструкторе вызван lock()
unique_lock&lt;mutex&gt; UL(Mtx, defer_lock);	//объявить unique_lock; в конструкторе не будет вызван lock()
UL.lock();								//разрешить доступ к участку кода только по одному потоку
UL.unlock();							//разрешить доступ к участку кода для всех потоков
В деструкторе unique_lock будет вызван unlock(), если сам метод не был вызван в участке кода до } или return
Дестркутор lock_guard и unique_lock вызывается во время удаления самого объекта [перед } или return]




<m>[C++] OBJECT ORIENTED PROGRAMING</m>
//по умолчанию поля и методы структуры имеют доступ public
//по умолчанию поля и методы класса имеют доступ private

//wrapper - класс содержит только одно поле
//class TMoney {int Money;}

//class tclass {};				- определение класса
//class tclass {} t1, t2;		- определение класса и объявление объектов этого класса
//tclass t;						- объявление объекта класса
//tclass *t;					- объявление указателя на объект класса
//tclass t[10];					- объявление массива объектов класса

//поля			- переменные класса
//методы		- функции класса (всегда имеют доступ к полям класса)
//private		- закрытый доступ (возможен вызов только внутри класса)
//protected		- защищенный доступ (возможен вызов только внутри класса и классов-наследников)
//public		- открытый доступ
//this			- скрытый указатель на текущий объект (this-&gt; - доступ к полям и методам текущего объекта)
//(*this)		- разыменование текущего объекта класса ((*this). - доступ к полям и методам текущего объекта)

//статическая память 		- все глобальные объекты (создаются: запуск программы; удаляются: выход из программы)
//автоматическая память		- локальные объекты (создаются: объявляются в блоке; удаляются: выход из видимости)
//динамическая память		- объекты через new/delete (создаются: new/new[]; удаляются: delete/delete[])
//== nullptr				- указатель ни на что не указывает

//константный метод класса гарантирует, что не будет изменять объект или вызывать неконстантные методы класса
//у константных полей и объектов класса можно вызывать только константные методы

//конструктор вызывается в момент создания объекта
//деструктор вызывается в момент удаления объекта
//деструктор не принимает параметры
//деструктор нельзя перегрузить
//объекты уничтожаются в обратном порядке тому, по которому они создавались

//конструкт копир, деструкт и operator= создаются автоматически (если в констукторе есть new/new[] их необходимо переопределить)
//для запрета конструктора копирования и операции "=" достаточно объявить эти методы в private
//конструктор по умолчанию не создается автоматически, если явно определен хотябы один конструктор
//const [тип] operator+(const [тип] t)	- запрещает многократное повторение (можно: a + b; нельзя: a + b + c)
//унарные операции						- один аргумент в перегрузке
//бинарные операции						- два аргумента в перегрузке

//friend - внешние функции, другие классы или методы других классов, которые имеют доступ к закрытым частям класса
//преобразование типа (int)a равносильно int(a)
//static_cast&lt;int&gt;		- преобразование типов char, short, int, uint, long, ulong, float, double, long double
//reinterpret_cast&lt;&gt;	- преобразование типов без проверки компиляции (используется, когда перем заним равный объем памяти)
//const_cast&lt;&gt;			- временно отменить константность
//void func(const int &a) {const_cast&lt;int&&gt;(a); a = 1;}	- функция с отменой константности (на выходе константа a не изменится)

//#include &lt;typeinfo&gt;		- для использования typeid() - функции возвращающей фактический тип класса (работает и с указателями)
//typeid(a) == typeid(b)	- true - a и b имеют одинаковый тип
//typeid(a).name()			- вывести название типа переменной a

<b>//перегрузка операций</b>
//операция присваивания:
//[тип]& operator=(const [тип] &)
//унарные арифметические операции:
//[тип]& operator+=(const [тип] &)
//[тип]& operator-=(const [тип] &)
//[тип]& operator*=(const [тип] &)
//[тип]& operator/=(const [тип] &)
//бинарные арифметические операции:
//friend operator+(const [тип] &, const [тип] &)
//friend operator-(const [тип] &, const [тип] &)
//friend operator*(const [тип] &, const [тип] &)
//friend operator/(const [тип] &, const [тип] &)
//или
//[тип] operator+(const [тип] &)
//[тип] operator-(const [тип] &)
//[тип] operator*(const [тип] &)
//[тип] operator/(const [тип] &)
//операции сравнения:
//bool operator==(const [тип] &)
//bool operator!=(const [тип] &)
//bool operator&gt;=(const [тип] &)
//bool operator&lt;=(const [тип] &)
//bool operator&gt;(const [тип] &)
//bool operator&lt;(const [тип] &)
//операции инкремента/декремента:
//[тип]& operator++()												//++[тип] - префиксная форма
//[тип] operator++(int)												//[тип]++ - постфиксная форма
//[тип]& operator--()
//[тип] operator--(int)
//операции индексирования:
//[тип]& operator[](const unsigned int &)							//arr[0] =
//const [тип]& operator[](const unsigned int &) const				//= arr[0]
//операции ввода-вывода:
//friend ostream& operator&lt;&lt;(ostream &, const [тип] &)
//friend istream& operator&gt;&gt;(istream &, [тип] &)
//операции неявного преобразования [тип текущего класса] -&gt; [тип]:
//operator [тип]() const

<b>//пример класса - 2d координата</b>
class T2DCoord
{
	int X;
	//можно захардкодить: int x = 0;
	int Y;
	//const int a;
	//константная переменная в классе (можно захардкодить или инициализ в списке инициализации конструктора)
public:
	//конструктор по умолчанию
	T2DCoord()
	{
		X = Y = 0;
	}
	//конструктор инициализации
	T2DCoord(const int &X, const int &Y = 0) noexcept
	//const unsigned int &y = 0	- позволяет не обязательно передавать параметр y (по умолчанию y = 0)
	//это позволяет вызывать конструктор так: t2dcoord coord(10); (где у объекта coord: x = 10, а y = 0)
	//const оберегает программиста от случайного изменения передаваемого параметра в теле конструктора
	//& - передача по ссылке (не копируется новый объект)
	//noexcept не позволяет методу выбрасывать исключения
	//explicit t2dcoord(const int &x, const int &y) - запретить неявные преобр
	//при explicit: t2dcoord a = {1, 1}; - ошибка трансл (можно t2dcoord a(1, 1))
	{
		this-&gt;X = X;
		this-&gt;Y = Y;
		//this-&gt;x - подсказывает компилятору, что мы обращаемся к полю класса, а не к параметру с тем же названием
	}
	//аналогично - t2dcoord(unsigned int X, unsigned int Y): X(X), Y(Y) {} - список инициализации конструктора
	//конструктор копирования
	T2DCoord(const T2DCoord &Other)
	{
		X = Other.X;
		Y = Other.Y;
	}
	//t2dcoord = t2dcoord + t2dcoord
	T2DCoord operator+(const T2DCoord &Other)
	{
		T2DCoord T = *this;
		T.X += Other.X;
		T.Y += Other.Y;
		return T;
	}
	//t2dcoord += t2dcoord
	T2DCoord& operator+=(const T2DCoord &Other)
	{
		X += Other.X;
		Y += Other.Y;
		return *this;
	}
	//++t2dcoord
	T2DCoord& operator++()
	{
		X += 1;
		Y += 1;
		return *this;
	}
	//t2dcoord++
	T2DCoord operator++(int)
	{
		T2DCoord T = *this;
		X += 1;
		Y += 1;
		return T;
	}
	//t2dcoord == t2dcoord
	bool operator==(const T2DCoord &Other)
	{
		return X == Other.X && Y == Other.Y;
	}
	//t2dcoord -&gt; int
	//неявное преобразование типов
	operator int() const
	{
		return X;
	}
	//const - константный метод - метод не изменяет параметры объекта; может вызывать только константные методы
	//t2dcoord = t2dcoord + t2dcoord
	friend T2DCoord operator+(const T2DCoord &First, const T2DCoord &Second)
	{
		T2DCoord T = First;
		T.X += Second.X;
		T.Y += Second.Y;
		return T;
	}
	//&lt;&lt; t2dcoord
	friend ostream& operator&lt;&lt;(ostream &Stream, const T2DCoord &T)
	{
		return Stream &lt;&lt; T.ToString();
	}
	//&gt;&gt; t2dcoord
	friend istream& operator&gt;&gt;(istream &Stream, T2DCoord &T)
	{
		Stream &gt;&gt; T.X;
		Stream &gt;&gt; T.Y;
		return Stream;
	}
	//вернуть строку (только объявление функции)
	string ToString() const;
	//true - координата = (0; 0) (только объявление функции)
	friend bool IsNull(const T2DCoord &T);
	//деструктор
	~T2DCoord()
	{
		//в деструкторе обычно вызываются методы очистки памяти динам переменных объявленных внутри класса (созданные через new)
		//например: delete[] Data;
	}
};
//t2dcoord:: вернуть строку (внешнее определение функции)
string T2DCoord::ToString() const
{
	return "(" + to_string(X) + "; " + to_string(Y) + ")";
}
//t2dcoord:: true - координата = (0; 0) (внешнее определение функции)
bool IsNull(const T2DCoord &T)
{
	return T.X == 0 && T.Y == 0;
}

<b>//пример класса с динамическим выделением памяти в конструкторах</b>
<b>//+ перегрузка операций индексирования</b>
//для классов, в конструкторах которых есть new/new[] необходимо переопределить конструктор копирования, operator= и деструктор
//tarray - целочисленный массив
class TArray
{
	int *Arr;
	unsigned int Size;
public:
	//конструктор инициализации
	TArray(const unsigned int &Size, const int &Value = 0)
	{
		if (Size &gt; 0)
		{
			this-&gt;Size = Size;
			Arr = new int[Size];
			for (int I = 0; I &lt; Size; I++) Arr[I] = Value;
		}
		else abort();
	}
	//конструктор копирования
	TArray(const TArray &Other)
	{
		//ошибка this-&gt;arr = t.arr
		Size = Other.Size;
		Arr = new int[Size];
		for (int I = 0; I &lt; Size; I++) Arr[I] = Other.Arr[I];
	}
	//tarray = tarray
	TArray& operator=(const TArray &Other)
	{
		if (this != &Other)							//проверить самоприсваивание
		{
			Size = Other.Size;
			int *TArr = new int[Size];
			for (int I = 0; I &lt; Size; I++) TArr[I] = Other.Arr[I];
			delete[] Arr;
			Arr = TArr;
		}
		return *this;
	}
	//tarray[] =
	int& operator[](const unsigned int &Index)
	{
		if (Index &lt; Size) return Arr[Index];
		else abort();
	}
	//= tarray[]
	const int& operator[](const unsigned int &Index) const
	{
		if (Index &lt; Size) return Arr[Index];
		else abort();
	}
	//деструктор
	~TArray()
	{
		delete[] Arr;
	}
};

<b>//операции c++ в порядке убывания приоритетов</b>
//::					область видимости									::name
//																			class::name
//																			namespace::name
//.						селектор компонента класса							object.member
//-&gt;					доступ к члену класса по указателю					pointer-&gt;member
//[]					индексирование										variable[expr]
//()					вызов функции										function()
//++					постфиксный инкремент								lvalue++
//--					постфиксный декремент								lvalue--
//sizeof				размер объекта										sizeof expr
//sizeof				размер типа											sizeof(type)
//++					префиксный инкремент								++lvalue
//--					префиксный декримент								--lvalue
//~						побитовое НЕ										~expr
//!						логическое НЕ										!expr
//-						унарный минус										-expr
//+						унарный плюс										+expr
//*						разыменование										*expr
//&						адрес												&expr
//()					приведение типа										(type)expr
//new					выделение памяти									new type
//																			new type(expr_list)
//new[]					выделение памяти под массив							new type[]
//delete				освобождение памяти									delete pointer
//delete[]				освобождение памяти из-под массива					delete[] pointer
//-&gt;*					разыменование указат на компонент класса по указат	pointer-&gt;*pointer_to_member
//.*					разыменование указателя на компонент класса			object.*ponter_to_member
//*						умножение											expr * expr
///						деление												expr / expr
//%						деление по модулю									expr % expr
//+						сложение											expr + expr
//-						вычитание											expr - expr
//&lt;&lt;					сдвиг влево											expr &lt;&lt; expr
//&gt;&gt;					сдвиг вправо										expr &gt;&gt; expr
//&lt;						меньше												expr &lt; expr
//&lt;=					меньше или равно									expr &lt;= expr
//&gt;						больше												expr &gt; expr
//&gt;=					больше или равно									expr &gt;= expr
//==					равно												expr == expr
//!=					не равно											expr != expr
//&						побитовое И											expr & expr
//^						побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ							expr ^ expr
//|						побитовое ИЛИ										expr | expr
//&&					логическое И										expr && expr
//||					логическое ИЛИ										expr || expr
//?:					условная операция									expr ? expr * expr
//=						присваивание										lvalue = expr
//*=; /=; %=; +=;		составное присваивание								lvalue += expr и тд
//-=; &lt;&lt;=; &gt;&gt;=; &=;	
//|=; ^=
//,						запятая												expr, expr

<b>//вложенные и объемлющие классы</b>
//вложенный и объемлющий классы не имеет доступа к приватным элементам друг друга
//для разрешения:
class Outer
{
	friend class Inner;
	class Inner
	{
		friend class Outer;
	};
};
//доступ к полям и методам вложенного класса доступен через outer::inner::

<b>//статические поля и методы в классе</b>
//статические поля и методы являются частью класса и создаются в единственном экземпляре (до создания объектов этого класса)
//статические поля и методы класса вызываются через объект этого класса или через ::
//инициализация статистических полей-массивов выполняется вне класса (static писать не нужно)
//static const double value;			- в классе
//const double tclass::value = 1.1		- вне класса
//внутри класса разрешается инициализировать только константные целочисленные статические поля
//изменение статических полей в одном объекте класса изменяет их во всех объектах этого класса
//неинициализированные статические поля инициализируются по умолчанию (0-м или конструктором по умолчанию)
//статические методы не могут быть константными, виртуальными и обращаться к this
//статические методы могут работать только со статическими полями и методами
//tstatic - статические поля и методы
class TStatic
{
	static const int M1 = 1;					//стат целочисленная инициализированная константа
	static const int M2;						//стат целочисленная константа
	static const double M3;						//стат вещественная константа
	static int M4;								//стат целочисленная переменная
	static double M5;							//стат вещественная переменная
	static const T2DCoord T1;					//стат объектная константа
	static T2DCoord T2;							//стат объектная переменная
public:
	static void Display()
	{
		cout &lt;&lt; "M1: " &lt;&lt; M1 &lt;&lt; endl;
		cout &lt;&lt; "M2: " &lt;&lt; M2 &lt;&lt; endl;
		cout &lt;&lt; "M3: " &lt;&lt; M3 &lt;&lt; endl;
		cout &lt;&lt; "M4: " &lt;&lt; M4 &lt;&lt; endl;
		cout &lt;&lt; "M5: " &lt;&lt; M5 &lt;&lt; endl;
		T1.Display();
		T2.Display();
	}
};
//определение стат полей static
const int TStatic::M2 = 1;						//обязательная инициализация
const double TStatic::M3 = 1.1;					//обязательная инициализация
int TStatic::M4;								//инициализация по умолчанию (0)
double TStatic::M5;								//инициализация по умолчанию (0)
const T2DCoord TStatic::T1(1, 1);				//конструктор инициализации
T2DCoord TStatic::T2;							//конструктор по умолчанию

<b>//наследование классов</b>
//конструкторы, деструктор, операция присваивания и дружественные функции не наследуются
//передать конструктор инициализации производному классу: tderived(int a): tbase(a) {}
//в списке инициализации конструктора производного класса нельзя инициализировать поля базового класса
//имена полей/методов базового и производного класса могут совпадать; обратится к такому полю/методу базов класса можно через ::
//в производном классе можно вызывать методы базового класса: tbase::func(); (через объект: t.tbase::func();)
//делегирование - вызов метода базового класса в одноименном методе производного класса
//указатель базового класса может хранить ссылку своего производного класса (не при private наследовании)
//объект производн класса может передаваться в параметры вместо объекта базов (не при private наслед; вызыват будут методы базов)
//срезка: t3dcoord c1(1, 2, 3); t2dcoord c2 = c1;
//по умолчанию классы наследуются, как private (структуры - как public)
//модификатор доступа при наследовании определяет доступность элементов базового класса в классе-наследнике
//мод наследования -&gt;		|	public			private			protected
//=======================================================================
//мод доступа в базовом:	|
//public					|	public			public			protected
//private					|	нет доступа		нет доступа		нет доступа
//protected					|	protected		protected		protected
//class tbase final {}	- запретить наследования для класса
//t2dcoord - 2d координата
class T2DCoord
{
protected:
	int X, Y;
public:
	T2DCoord(): X(0), Y(0) {}
	T2DCoord(const int &X, const int &Y): X(X), Y(Y) {}
	int GetX() const
	{
		return X;
	}
	int GetY() const
	{
		return Y;
	}
};
//t3dcoord - 3d координата
class T3DCoord: public T2DCoord
{
protected:
	int Z;
public:
	T3DCoord(const int &X, const int &Y, const int &Z): T2DCoord(X, Y), Z(Z) {}
	T3DCoord(const T2DCoord &Other)					//для инициализации t3dcoord(t2dcoord)
	{
		T2DCoord::T2DCoord(Other);
		Z = 0;
	}
	int GetZ() const
	{
		return Z;
	}
	T3DCoord& operator=(const T2DCoord &Other)		//для операции coord3d = coord2d
	{
		T2DCoord::operator=(Other);
		return *this;
	}
};
//наследование и вложенные классы
class A {};											//внешний класс
class B {public: class C: public A {};};			//вложенный класс наследует от внешнего
class D: public B::C {};							//внешний класс наследует от вложенного
class E {class F: public B::C {};};					//вложенный класс наследует от вложенного

<b>//вирутальные методы</b>
//virtual метод базового класса позволяет переопределять этот метод в производных классах
//virtual метод, как и сама виртуальность наследуется
//virtual void func() {} - вирт метод в базовом классе; void func() override {} - переопределение вирт метода в производ классе
//virtual void func() final {} - запрет переопределения
//без override компилятор просто создаст в классе метод с таким же названием (перегр), а не переопределит вирт метод базов класса
//виртуальные методы можно перегружать
//конструкторы, статические методы и дружественные функции не могут быть виртуальными
//в производном классе можно вызывать виртуальные методы базового класса: tbase::func(); (через объект: t.tbase::func();)
//titem - предмет
class TItem
{
protected:
	string ItemName;
	string Owner;
public:
	TItem(const string &ItemName, const string &Owner): ItemName(ItemName), Owner(Owner) {}
	virtual string ToString() const
	{
		return "itemname[" + ItemName + "]_owner[" + Owner + "]";
	}
};
//tarmor - броня
class TArmor: public TItem
{
protected:
	int Resist;
public:
	TArmor(const string &ItemName, const string &Owner, const int &Resist): TItem(ItemName, Owner), Resist(Resist) {}
	string ToString() const override
	{
		return "itemname[" + ItemName + "]_owner[" + Owner + "]_resist[" + to_string(Resist) + "]";
	}
};

<b>//чистые виртуальные методы</b>
//virtual void func() = 0;		- чистый виртуальный метод - виртуальный метод без определения
//абстрактный класс				- класс, в котором есть хотя бы один чистый виртуальный метод
//интерфейс						- класс, состоящий только из чистых виртуальных методов
//невозможно объявить объект абстрактного класса
//абстрактность передается по наследству, если производный класс не реализует чистые виртуальные методы (=&gt; он тоже абстрактный)
//tweapon - вооружение (абстрактный класс)
class TWeapon
{
protected:
	string WeaponName;
	unsigned Damage;
public:
	TWeapon(const string &WeaponName, const unsigned &Damage): WeaponName(WeaponName), Damage(Damage) {}
	virtual void Attack() const = 0;
};
//производный класс tclaymore от абстрактного weapon
class TClaymore: public TWeapon
{
public:
	TClaymore(const string &WeaponName, const unsigned &Damage): TWeapon(WeaponName, Damage) {}
	void Attack() const override
	{
		cout &lt;&lt; "claymore attack! = " &lt;&lt; Damage &lt;&lt; endl;
	}
};
//производный класс tglaive от абстрактного weapon
class TGlaive: public TWeapon
{
public:
	TGlaive(const string &WeaponName, const unsigned &Damage): TWeapon(WeaponName, Damage) {}
	void Attack() const override
	{
		cout &lt;&lt; "glaive attack! = " &lt;&lt; Damage &lt;&lt; endl;
	}
};

<b>//множественное наследование</b>
//множественное наследование рекомендуется применять только для классов-интерфейсов
//неоднозначность - совпадение имен полей и методов в двух базовых классах (необходимо указывать доступ ::)
//класс tonehandedsword - одноручный меч
class TOneHandedSword
{
public:
	void Attack()
	{
		cout &lt;&lt; "tonehandedsword::attack" &lt;&lt; endl;
	}
};
//класс ttwohandedsword - двуручный меч
class TTwoHandedSword
{
public:
	void Attack()
	{
		cout &lt;&lt; "ttwohandedsword::attack" &lt;&lt; endl;
	}
};
//класс tbastardsword - полуторный меч
class TBastardSword: public TOneHandedSword, public TTwoHandedSword {};
int main()
{
	TBastardSword BastardSword;
	BastardSword.TOneHandedSword::Attack();
	BastardSword.TTwoHandedSword::Attack();
}

<b>//ромбовидное наследование</b>
//двухуровневое наследование:
//поля и методы класса a повторяются
//[c::b1::a:: и c::b2::a:: - разные области видимости; конструктор класса a вызывается два раза для b1 и b2]
// a     a
// |     |
// b1   b2
//   \ /
//    c
class A {};
class B1: public A {};
class B2: public A {};
class C: public B1, public B2 {};
//ромбовидное наследование
//класс a является вирт базовым классом для производных классов b1 и b2 =&gt; в классе c оказывается единственная копия полей класса a
//[c::b1::a:: и c::b2::a:: - одна и таже область видимости; конструктор класса a вызывается один раз]
//    a
//   / \
// b1   b2
//   \ /
//    c
class A {};
class B1: virtual public A {};
class B2: virtual public A {};
class C: public B1, public B2 {};
//список инициализации конструктора класса c
//[у каждого класса своя одна одноименная переменная]
C(const int &a1, const int &b1, const int &a2, const int &b2, const int &c): B1(a1, b1), B2(a2, b2), c(c) {}	//при двухур наслед
C(const int &a, const int &b1, const int &b2, const int &c): A(a), B1(a, b1), B2(a, b2), c(c) {}				//при ромб наслед

<b>//деструкторы, виртуальные деструкторы и чистые виртуальные деструкторы</b>
//порядок вызова конструкторов и деструкторов объекта:
//произвд класса						- констр tbase &gt; констр tderived &gt; дестр tderived &gt; дестр tbase
//произвд класса при множ наслед		- констр tbase1 &gt; констр tbase2 &gt; констр tderived &gt; дестр tderived &gt; дестр tbase2 &gt; дестр tbase1
//при наследовании деструкторы базовых классов дожны быть виртуальными
//[иначе при tbase *derptr = new tderived(); вызовется только деструктор tbase]
//[при выделении динам памяти new/delete в конструкторах - деструктор базового класса должен быть виртуальным]
//чист вирт деструкт нужен, чтобы сделать класс абстракт, не создавая чист вирт методов [+ защита от утеч памяти при new/delete]
//чистый виртуальный деструктор должен быть внешне определен
//деструкторы не наследуются =&gt; производный класс не абстрактный

<b>//template&lt;typename&gt;</b>
//template &lt;typename t&gt; позволяет передавать в параметры переменную любого типа
template&lt;typename T&gt;						//tclass&lt;[тип]&gt; t;
template&lt;typename T1, typename T2&gt;			//tclass&lt;[тип], [тип]&gt; t;
template&lt;typename T1, typename T2 = int&gt;	//tclass&lt;[тип], [тип]&gt; t; или tclass&lt;[тип]&gt; t; (typename t2 = int - по умолчанию 2-й тип int)
template&lt;typename T1, unsigned Value&gt;		//tclass&lt;[тип], 10&gt; t; (value - передаваемое в класс значение; его тип не может быть классом)
template&lt;typename T1, unsigned Value = 1&gt;	//tclass&lt;[тип], 10&gt; t; или tclass&lt;[тип]&gt; t; (unsigned value = 1 - по умолчанию value = 1)
//при внешнем определении метода класса всегда дописывается template&lt;typename&gt;
template&lt;typename T&gt;
void TClass&lt;T&gt;::Func() {}
//tstringentry - запись строки
template&lt;typename T1, typename T2&gt;
class TStringEntry
{
	T1 FirstInfo;
	T2 SecondInfo;
public:
	TStringEntry(): FirstInfo(), SecondInfo() {}
	TStringEntry(const T1 &FirstInfo, const T2 &SecondInfo): FirstInfo(FirstInfo), SecondInfo(SecondInfo) {}
	T1 GetFirstInfo()
	{
		return FirstInfo;
	}
	T2 GetSecondInfo()
	{
		return SecondInfo;
	}
};
//tarray - статический массив
template&lt;typename T, size_t Size&gt;
class TArray
{
	T Elem[Size];
public:
	const size_t Length = Size;
	//конструктор инициализации постоянным элементом
	TArray(const T &_T = T())							//= T() - вызов констр по умолч передан типа (для стандарт типов - иниц 0-м)
	{															
		for (int I = 0; I &lt; Size; I++) Elem[I] = _T;
	}
	T& operator[](const unsigned int &Index)
	{
		if (Index &gt;= Length) throw range_error("err::out_of_range");
		return Elem[Index];
	}
	const T& operator[](const unsigned int &Index) const
	{
		if (Index &gt;= Length) throw range_error("err::out_of_range");
		return Elem[Index];
	}
};

<b>//стандартные исключения</b>
//throw		- брость исключение
//try		- перехватить исключение
//catch		- обработать исключение
//после throw exception; программа сразу начинает выполнение команд подходящего по типу исключения блока catch
//try/catch блок лучше реализовать в main, тк код продолжает выполнение после блоков catch
//исключения не ловятся дважды (те выполняется только один первый подходящий по типу исключения блок catch)
//catch ловит точно свой тип (преобразования типов не производится для стандартных типов)
//catch исключений базовых классов-исключений ловит и исключения производных классов-исключений
//throw 1;							- бросить целочисленное исключение (ловится только в int)
//throw 1.1;						- бросить вещественное исключение (ловится только в double)
//throw "error";					- бросить строковое исключение (ловится только в const char *)
//throw exception("");				- бросить стандартный класс exception
//catch (int)						- перехватить целочисленное исключение
//catch (double)					- перехватить вещественное исключение
//catch (const char *)				- перехватить строкове исключение
//catch (const exception &ex)		- перехватить стандартный класс exception (ex.what() - вернуть текст исключения)
//catch (...)						- перехватить все исключения (обязательно последним, иначе там перехватятся все исключения)
//texception - пользовательский exception (производный от стандартн exception)
class TException: public exception
{
	int State;
public:
	TException(const char *Msg, int State): exception(Msg), State(State) {}
	int GetState() const
	{
		return State;
	}
};
int main()
{
	try
	{
		throw TException("texception", -1);		//throw может быть и внутри функций, вызванных в области видимости try {}
		throw exception("exception");
	}
	catch (const TException &Ex)				//обязательно перед catch (const exception &ex) {}
	{
		cout &lt;&lt; Ex.what() &lt;&lt; " state: " &lt;&lt; Ex.GetState() &lt;&lt; endl;
	}
	catch (const exception &Ex) {}				//catch (const exception &ex) ловит и const texception &ex
	catch (...) {}								//обязательно последним (ловит все исключения)
}
//#include &lt;stdexcept&gt;	- стандартная библиотека исключений
//throw runtime_error("");
//throw range_error("");
//throw invalid_argument("");
//throw length_error("");
//эти классы-исключения stdexcept наследуются от станд класса exception (их catch нужно ставить перед catch (const exception&))
</div>
</body>
</html>
