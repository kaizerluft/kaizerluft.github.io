<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<title>C++</title>
	<link href="style.css" rel="stylesheet" type="text/css">
</head>
<body>
<script src="menu.js"></script>
<div class="text">


<m>[C++] ITERATOR</m>
<b>iterator</b> - структура данных, которая используется для обращения к определенному элементу в контейнерах STL
Итератор должен быть такого же типа как и контейнер, на который он ссылается
#include &lt;iterator&gt;	//подключить заголовочный файл &lt;iterator&gt;
<b>Объявление Iterator</b>
vector&lt;int&gt;::iterator It				//объявить итератор
vector&lt;int&gt;::const_iterator It			//объявить итератор без доступа к изменению значений
vector&lt;int&gt;::iterator It = V.begin()	//объявить итератор и инициализировать итератором начала вектора
<b>Действия Iterator</b>
It += N						//сместить итератор на N элементов вправо (недоступно для типов list, set, map)
advance(It, N)				//сместить итератор на N элементов вправо
It++						//сместить итератор на один элемент вправо
It--						//сместить итератор на один элемент влево
It1 == It2 || It1 != It2	//сравнить два итератора (операции &lt;&gt; недоступны для типов list, set, map)
cout &lt;&lt; *It					//вывести значение элемента с позицией It
*It += N					//прибавить N к значению элемента с позицией It
int Diff = It1 - It2		//передать переменной разницу итераторов
auto It = V.begin()			//эквивалент: vector&lt;int&gt;::iterator It = V.begin();




<m>[C++] STRING</m>
<b>string</b> - класс с методами и переменными для организации работы со строками
#include &lt;string&gt;	//подключить заголовочный файл &lt;string&gt;
<b>Объявление String</b>
string Str			//объявить строку
string Str = "text"	//объявить и инициализировать строку
<b>Ввод и Вывод String</b>
cin &gt;&gt; Str			//ввести строку до пробела или каретки
getline(cin, Str)	//ввести всю строку
cout &lt;&lt; Str			//вывести строку
<b>Арифметические Операции String</b>
=				//присвоить значение одной строки другой
+=				//добавить в конец строки другую строку
+				//конкатенировать две строки
==; !=			//сравнить две строки посимвольно
&lt;; &gt;; &lt;=; &gt;=	//сравнить две строки лексикографически
Str[0]			//обратиться к первому символу строки
<b>Методы String</b>
Str.push_back(Sign)						//добавить символ
Str.size()								//вернуть размер
Str.length()							//вернуть размер
Str.resize(N)							//изменить размер
Str.resize(N, Sign)						//изменить размер, изменяя новые символы
Str.clear()								//очистить
Str.empty()								//true, если пуст
Str.begin()								//вернуть итератор начала
Str.end()								//вернуть итератор конца
Str.insert(Pos, N, Sign)				//вставить в позицию символ N раз
Str1.insert(Pos, Str2)					//вставить в позицию строку
Str1.insert(Pos1, Str2, Pos2, N)		//вставить в позицию строку от Pos N символов
Str.insert(It, Sign)					//вставить в итератор символ
Str.insert(It, N, Sign)					//вставить в итератор символ N раз
Str.insert(It1, It2, It3)				//вставить в итератор символы из диапазона
Str.append(N, Sign)						//добавить символ N раз
Str1.append(Str2)						//добавить строку
Str1.append(Str2, Pos, N)				//добавить строку от Pos N символов
Str.replace(Pos, N1, N2, Sign)			//удалить от Pos N1 символов и вставить символ N2 раз
Str1.replace(Pos, N, Str2)				//удалить от Pos N символов и вставить строку
Str1.replace(Pos1, N1, Str2, Pos2, N2)	//удалить от Pos1 N1 символов и вставить строку от Pos2 N2 символов
Str.erase(Pos)							//удалить символы с позиции
Str.erase(Pos, N)						//удалить символы с позиции N раз
Str.erase(It)							//удалить символ с итератора
Str.erase(It1, It2)						//удалить символы из диапазона итераторов
Str.substr(Pos)							//вернуть подстроку с позиции
Str.substr(Pos, N)						//вернуть подстроку с позиции N символов
Str1.swap(Str2)							//обменять значения
Str1.find(Str2)							//вернуть позицию встречи строки
Str1.find(Str2, Pos)					//вернуть позицию встречи строки поиск от Pos
Str1.find(Str2, Pos, N)					//вернуть позицию встречи N символов строки поиск от Pos
Str1.rfind(Str2)						//вернуть позицию встречи строки поиск справа
Str1.rfind(Str2, Pos)					//вернуть позицию встречи строки поиск от Pos справа
Str1.rfind(Str2, Pos, N)				//вернуть позицию встречи N символов строки поиск от Pos справа
Str1.find_first_of(Str2)				//вернуть позицию встречи символа из строки
Str1.find_first_of(Str2, Pos)			//вернуть позицию встречи символа из строки поиск от Pos
Str1.find_last_of(Str2)					//вернуть позицию встречи символа из строки поиск справа
Str1.find_last_of(Str2, Pos)			//вернуть позицию встречи символа из строки поиск от Pos справа
Str1.find_first_not_of(Str2)			//вернуть позицию встречи символа не из строки
Str1.find_first_not_of(Str2, Pos)		//вернуть позицию встречи символа не из строки поиск от Pos
Str1.find_last_not_of(Str2)				//вернуть позицию встречи символа не из строки поиск справа
Str1.find_last_not_of(Str2, Pos)		//вернуть позицию встречи символа не из строки поиск от Pos справа
Str.c_str()								//вернуть строку как указатель типа char*




<m>[C++] VECTOR</m>
<b>vector</b> - структура данных, которая уже является моделью динамического массива
#include &lt;vector&gt;	//подключить заголовочный файл &lt;vector&gt;
<b>Объявление Vector</b>
vector&lt;int&gt; V								//объявить вектор
vector&lt;int&gt; V(N)							//объявить нулевой вектор размером N
vector&lt;int&gt; V(N, Value)						//объявить вектор размером N со значениями Value
vector&lt;vector&lt;int&gt;&gt; V						//объявить двумерный вектор
vector&lt;vector&lt;int&gt;&gt; V(N, vector&lt;int&gt;(M))	//выделить память двумерному вектору размером N*M
<b>Арифметические Операции Vector</b>
=				//присвоить значение одного вектора другому
==; !=			//сравнить два вектора поэлементно
&lt;; &gt;; &lt;=; &gt;=	//сравнить два вектора лексикографически
V[0]			//обратиться к первому элементу вектора
V[0][0]			//обратиться к первому элементу двумерного вектора
<b>Методы Vector</b>
V.at(I)					//обратиться к I-му элементу с генерацией исключения
V.front()				//вернуть первый элемент
V.back()				//вернуть последний элемент
V.push_back(Value)		//добавить элемент
V.emplace_back(Value)	//добавить элемент
V.pop_back()			//удалить последний элемент
V.size()				//вернуть размер
V.resize(N)				//изменить размер
V.resize(N, Value)		//изменить размер, изменяя новые элементы
V.clear()				//очистить
V.empty()				//true, если пуст
V.reserve(Byte)			//зарезервировать объем памяти
V.capacity()			//вернуть объем памяти
V.shrink_to_fit()		//освободить память
V.begin()				//вернуть итератор начала
V.end()					//вернуть итератор конца
V.insert(It, Value)		//вставить в итератор элемент
V.insert(It, N, Value)	//вставить в итератор элемент N раз
V.insert(It1, It2, It3)	//вставить в итератор элементы из диапазона итераторов
V.erase(It)				//удалить элемент с итератора
V.erase(It1, It2)		//удалить элементы из диапазона итераторов
V1.swap(V2)				//обменять значения




<m>[C++] LIST</m>
<b>list</b> - структура данных, каждый элемент списка знает только о предыдущем и о следующем элементах
#include &lt;list&gt;	//подключить заголовочный файл &lt;list&gt;
<b>Объявление List</b>
list&lt;int&gt; L				//объявить список
list&lt;int&gt; L(N)			//объявить нулевой список размером N
list&lt;int&gt; L(N, Value)	//объявить список размером N со значениями Value
<b>Арифметические Операции List</b>
=				//присвоить значение одного списка другому
==; !=			//сравнить два списка поэлементно
&lt;; &gt;; &lt;=; &gt;=	//сравнить два списка лексикографически
У двусвязного списка отсутсвуют индексы, вместо них используются итераторы
<b>Методы List</b>
L.front()				//вернуть первый элемент
L.back()				//вернуть последний элемент
L.push_front(Value)		//добавить элемент в начало
L.push_back(Value)		//добавить элемент в конец
L.pop_front()			//удалить первый элемент
L.pop_back()			//удалить последний элемент
L.size()				//вернуть размер
L.clear()				//очистить
L.empty()				//true, если пуст
L.begin()				//вернуть итератор начала
L.end()					//вернуть итератор конца
L.insert(It, Value)		//вставить в итератор элемент
L.insert(It, N, Value)	//вставить в итератор элемент N раз
L1.merge(L2)			//добавить список
L.erase(It)				//удалить элемент с итератора
L.erase(It1, It2)		//удалить элементы из диапазона итераторов
L.remove(Value)			//удалить элементы со значением
L.remove_if(Condition)	//удалить элементы с условием
L.unique()				//удалить повторяющиеся элементы
L1.swap(L2)				//обменять значения




<m>[C++] STACK</m>
<b>stack</b> - структура данных, в которой доступ осуществляется только к последнему добавленному элементу
#include &lt;stack&gt;	//подключить заголовочный файл &lt;stack&gt;
<b>Объявление Stack</b>
stack&lt;int&gt; St				//объявить стек (по умолчанию на основе deque)
stack&lt;int, vector&lt;int&gt;&gt; St	//объявить стек на основе vector
<b>Арифметические Операции Stack</b>
=				//присвоить значение одного стека другому
==; !=			//сравнить два стека поэлементно
&lt;; &gt;; &lt;=; &gt;=	//сравнить два стека лексикографически
Стек не работает с итераторами
<b>Методы Stack</b>
St.peek(I)			//обратиться к I-му элементу стека от вершины
St.top()			//вернуть верхний элемент стека
St.push(Value)		//добавить элемент
St.emplace(Value)	//добавить элемент
St.poop()			//удалить элемент
St.size()			//вернуть размер
St.empty()			//true, если пуст
St1.swap(St2)		//обменять значения




<m>[C++] QUEUE</m>
<b>queue</b> - структура данных, в которой доступ осуществляется только к самому раннее добавленому элементу
Новые элементы добавляются в конец очереди, а удаляются из начала очереди
#include &lt;queue&gt;	//подключить заголовочный файл &lt;queue&gt;
<b>Объявление Queue</b>
queue&lt;int&gt; Qu				//объявить очередь (по умолчанию на основе deque)
queue&lt;int, list&lt;int&gt;&gt; Qu	//объявить очередь на основе list
<b>Арифметические Операции Queue</b>
=				//присвоить значение одной очереди другой
==; !=			//сравнить две очереди поэлементно
&lt;; &gt;; &lt;=; &gt;=	//сравнить две очереди лексикографически
<b>Методы Queue</b>
Qu.front()			//вернуть первый элемент
Qu.back()			//вернуть последний элемент
Qu.push(Value)		//добавить элемент в конец очереди
Qu.emplace(Value)	//добавить элемент в конец очереди
Qu.pop()			//удалить первый элемент
Qu.size()			//вернуть размер
Qu.empty()			//true, если пуст
Qu.swap()			//обменять значения




<m>[C++] DEQUE</m>
<b>deque</b> - структура данных, позволяющая добавлять элементы в конец и в начало, удалять элементы из конца и из начала
#include &lt;deque&gt;	//подключить заголовочный файл &lt;deque&gt;
<b>Объявление Deque</b>
deque&lt;int&gt; Dq							//объявить дек
deque&lt;int&gt; Dq(N)						//объявить нулевой дек размером N
deque&lt;int&gt; Dq(N, Value)					//объявить дек размером N со значениями Value
deque&lt;deque&lt;int&gt;&gt; Dq					//объявить двумерный дек
deque&lt;deque&lt;int&gt;&gt; Dq(N, deque&lt;int&gt;(M))	//выделить память двумерному деку размером N*M
<b>Арифметические Операции Deque</b>
=				//присвоить значение одного дека другому
==; !=			//сравнить два дека поэлементно
&lt;; &gt;; &lt;=; &gt;=	//сравнить два дека лексикографически
Dq[0]			//обратиться к первому элементу дека
Dq[0][0]		//обратиться к первому элементу двумерного дека
<b>Методы Deque</b>
Dq.at(I)					//обратиться к I-му элементу с генерацией исключения
Dq.front()					//вернуть первый элемент
Dq.back()					//вернуть последний элемент
Dq.push_front(Value)		//добавить элемент в начало
Dq.push_back(Value)			//добавить элемент в конец
Dq.emplace_front(Value)		//добавить элемент в начало
Dq.emplace_back(Value)		//добавить элемент в конец
Dq.pop_front()				//удалить первый элемент
Dq.pop_back()				//удалить последний элемент
Dq.size()					//вернуть размер
Dq.resize(N)				//изменить размер
Dq.resize(N, Value)			//изменить размер, изменяя новые элементы
Dq.clear()					//очистить
Dq.empty()					//true, если пуст
Dq.begin()					//вернуть итератор начала
Dq.end()					//вернуть итератор конца
Dq.insert(It, Value)		//вставить в итератор элемент
Dq.insert(It, N, Value)		//вставить в итератор элемент N раз
Dq.insert(It1, It2, It3)	//вставить в итератор элементы из диапазона итераторов
Dq.erase(It)				//удалить элемент с итератора
Dq.erase(It1, It2)			//удалить элементы из диапазона итераторов
Dq1.swap(Dq2)				//обменять значения




<m>[C++] SET / MULTISET</m>
<b>set</b> - структура данных, хранящая все элементы в порядке возрастания без повторяющихся значений
<b>multiset</b> - структура данных, хранящая все элементы в порядке возрастания с возможностью повторения значений
#include &lt;set&gt;	//подключить заголовочный файл &lt;set&gt;
<b>Объявление Set</b>
set&lt;int&gt; S			//объявить множество
multiset&lt;int&gt; MS	//объявить мультимножество
<b>Арифметические Операции Set</b>
=				//присвоить значение одного множества другому
==; !=			//сравнить два множества поэлементно
&lt;; &gt;; &lt;=; &gt;=	//сравнить два множества лексикографически
<b>Методы Set</b>
S.size()				//вернуть размер
S.clear()				//очистить
S.empty()				//true, если пуст
S.begin()				//вернуть итератор начала
S.end()					//вернуть итератор конца
S.insert(Value)			//вставить элемент
S.insert(It, Value)		//вставить в итератор элемент
S.insert(It1, It2)		//вставить в итератор элементы из диапазона итераторов
S.erase(Value)			//удалить элемент
S.erase(It)				//удалить элемент с итератора
S.erase(It1, It2)		//удалить элементы из диапазона итераторов
S1.swap(S2)				//обменять значения
S.count(Value)			//вернуть количество элементов
S.find(Value)			//вернуть итератор встречи элемента
S.lower_bound(Value)	//вернуть итератор встречи элемента большее или равное значению
S.upper_bound(Value)	//вернуть итератор встречи элемента большее значению




<m>[C++] MAP / MULTIMAP</m>
<b>map</b> - ассоциативный контейнер, который работает по принципу - [ключ - значение] без повторяющихся ключей
<b>multimap</b> - ассоциативный контейнер, который работает по принципу - [ключ - значение] с возможностью повтора ключей
#include &lt;map&gt;	//подключить заголовочный файл &lt;map&gt;
<b>Объявление Map</b>
map&lt;int, string&gt; M			//объявить словарь
multimap&lt;int, string&gt; MM	//объявить мультисловарь
<b>Арифметические Операции Map</b>
=				//присвоить значение одного словаря другому
==; !=			//сравнить два словаря поэлементно
&lt;; &gt;; &lt;=; &gt;=	//сравнить два словаря лексикографически
M[0] = "text"	//присвоить значение по ключу
Если обратиться к несуществующему ключу и присвоить ему значение, то в словаре добавится новая пара
M[0].First	//обратиться к ключу
It-&gt;First	//обратиться к ключу через итератор
M[0].Second	//обратиться к значению
It-&gt;Second	//обратиться к значению через итератор
Невозможно изменить значение ключа при обращении через итератор It-&gt;First
<b>Методы Map</b>
M.at(I)									//обратиться к I-му элементу с генерацией исключения
M.size()								//вернуть размер
M.clear()								//очистить
M.empty()								//true, если пуст
M.begin()								//вернуть итератор начала
M.end()									//вернуть итератор конца
M.emplace(Key, Value)					//добавить элемент
M.insert(make_pair(Key, Value))			//вставить элемент
M.insert(pair&lt;int, int&gt;(Key, Value))	//вставить элемент
M.insert(It, make_pair(Key, Value))		//вставить в итератор элемент
M.insert(It1, It2)						//вставить элементы из диапазона итераторов
M.erase(Key)							//удалить элемент
M.erase(It)								//удалить элемент с итератора
M.erase(It1, It2)						//удалить элементы из диапазона итераторов
M1.swap(M2)								//обменять значения
M.count(Key)							//вернуть количество элементов
M.find(Key)								//вернуть итератор встречи элемента
M.lower_bourd(Key)						//вернуть итератор встречи элемента большее или равное ключу
M.upper_bound(Key)						//вернуть итератор встречи элемента большее ключу




<m>[C++] ALGORITHM / LAMBDA</m>
#include &lt;algorithm&gt;	//подключить заголовочный файл &lt;algorithm&gt;
+inserter - возможность вставить элементы через методы:
1) inserter(Container, It)
2) front_inserter(Container)
3) back_inserter(Container)
<b>Condition</b>
Condition - булевская или анонимная функция (например, [](int El){return El = 0;})
В параметры передается только имя булевской функции []
<b>Методы Algorithm</b>
copy(It1, It2, It3)					//копировать элементы (+inserter)
copy_if(It1, It2, It3, Condition)	//копировать элементы с условием (+inserter)
move(It1, It2, It3)					//вставить элементы с замещением (+inserter)
remove(It1, It2, Value)				//убрать элементы за возвращаемый итератор
remove_if(It1, It2, Condition)		//убрать элементы за возвращаемый итератор c условием
unique(It1, It2)					//убрать неуникальные элементы за возвращаемый итератор
unique_copy(It1, It2, It3)			//копировать уникальные элементы (+inserter)
min_element(It1, It2)				//вернуть минимальный элемент
max_element(It1, It2)				//вернуть максимальный элемент
minmax_element(It1, It2)			//вернуть пару из минимального и максимального элемента
count(It1, It2, Value)				//вернуть кольчество элементов
count_if(It1, It2, Condition)		//вернуть количество элементов с условием
equal(It1, It2, It3, It4)			//true, если диапазоны итераторов содержат одинаковые элементы
sort(It1, It2)						//сортировать элементы по возрастанию
random_shuffle(It1, It2)			//переставить элементы в случайном порядке
rotate(It1, It1 + N, It2)			//сместить элементы на N
rotate_copy(It1, It1 + N, It2, It3)	//сместить элементы на N с копированием (+inserter)
reverse(It1, It2)					//развернуть элементы в обратном порядке
binary_search(It1, It2, Value)		//true, если элемент присутствует (контейнер упорядочен)
find(It1, It2, Value)				//вернуть итератор встречи элемента
find_if(It1, It2, Condition)		//вернуть итератор встречи элемента по условию
lower_bound(It1, It2, Value)		//вернуть итератор встречи элемента большее или равное значению
upper_bound(It1, It2, Value)		//вернуть итератор встречи элемента большее значению
<b>Лямбда функция</b> - безымянная локальная функция, которую можно создавать прямо внутри какого-либо выражения
<b>Объявление анонимной функции</b>
[]() {};
Где:
[]					//список внешних захватываемых объектов
()					//параметры анонимной функции
{}					//тело анонимной функции
auto F = []() {};	//присвоить переменной класс лямбда [тип переменной зависит от возвращаемого значения]
[]()->int {};		//жесткое указание типа возвращаемого значения
[&X, &Y]			//передача внешних параметров по ссылке
[=]					//передача всех внешних параметров по значению [нельзя изменять в теле лямбды]
[=]()mutable		//передача всех внешних параметров по значению [можно изменять только в теле лямбды]
[&]					//передача всех внешних параметров по ссылке
[this]				//передача полей и методов класса




<m>[C++] WSTRING / RUS</m>
<b>wstring</b> - структура данных "широких" локализованных символов, интернациональная кодировка символами Unicode
<b>Действия Wstring</b>
setlocale(LC_ALL, ".866")	//добавить кодировку с русскими символами
wstring Wstr = L"текст"		//объявить и инициализировать широкую строку
wcin &gt;&gt; Wstr				//ввести широкую строку
wcout &lt;&lt; Wstr				//вывести широкую строку
wcout &lt;&lt; L"текст"			//вывести русский текст
<b>Считать с Файла "file.txt" Строку с русским Текстом</b>
wstring Buff;
wifstream Fin("file.txt");
Fin.imbue(locale("Russian"));
getline(Fin, Buff);




<m>[C++] BINARY FILES</m>
При записи информации в двоичный файл символы и числа записываются в виде последовательности байт
#include &lt;fstream&gt;	//подключить заголовочный файл &lt;fstream&gt;
<b>Действия Fstream</b>
FILE *File								//объявить файловую переменную
fopen_s(&File, FileName, Mode)			//открыть файл в режиме
fread(&Value, sizeof(int), 1, File)		//считать sizeof() байт в переменную
fread(Arr, sizeof(int), N, File)		//считать sizeof()*N байт в массив
fwrite(&Value, sizeof(int), 1, File)	//записать sizeof() байт в переменную
fwrite(Arr, sizeof(int), N, File)		//записать sizeof()*N байт в массив
fseek(File, sizeof(int) * N, SEEK)		//переместить указатель файла к заданному байту
feof(File)								//true, если достигнут конец файла
fclose(File)							//закрыть файл
rename(FileName1, FileName2)			//переименовать файл
remove(FileName)						//удалить файл
<b>Режим Работы</b>
"rb"	//открыть в режиме чтения
"wb"	//создать для записи; файл очищается
"ab"	//создать/открыть для дозаписи в конец файла
"rb+"	//открыть в режиме чтения и записи
"wb+"	//открыть в режиме чтения и записи; файл очищается
"ab+"	//создать/открыть для исправления и дозаписи в конец файла
<b>Значение Смещения</b>
SEEK_SET	//с начала файла
SEEK_CUR	//с текущей позиции
SEEK_END	//с конца файла




<m>[C++] AUTO_PTR / UNIQUE_PTR / SHARED_PTR</m>
<b>auto_ptr</b> - умный указатель, затирает память указателя, который указывает на ту же область данных [затирается предыдущий]
auto_ptr&lt;int&gt; AP1(new int(5));
auto_ptr&lt;int&gt; AP2(AP1);			//ap1 стерся; ap2 = 5
<b>unique_ptr</b> - уникальный указатель, запрещена возможность одного указателя ссылаться на область другого указателя
unique_ptr&lt;int&gt; UP1(new int(5));
unique_ptr&lt;int&gt; UP2(UP1);			//недопускается компилятором [возможно: up2 = move(up1); up2.swap(up1)]
UP1.get();		//вернуть сырой указатель [raw pointer - *ptr]
UP1.reset();	//затереть данные указателя
UP1.release();	//сохранить данные; освободить их взаимосвязь с указателем
<b>shared_ptr</b> - владение указателями одним и тем же объектом в памяти [данные уничтожатся, когда униктожен последний указатель]




<m>[C++] МНОГОМОДУЛЬНЫЕ ПРОЕКТЫ</m>
<b>//код файла "%CLASSNAME.H%"</b>
#pragma once
#include &lt;iostream&gt;
using namespace std;
void Func1(int A);
void Func2(int A);
<b>//код файла "%CLASSNAME.CPP%"</b>
#include "%CLASSNAME.H%"
void Func1(int A) {...}
void Func2(int A) {...}
<b>//код файла "%MAIN.CPP%"</b>
#include "%CLASSNAME.H%"
int main {...}




<m>[C++] NAMESPACE</m>
namespace NameSpace {}		//объявить пространство имен
NameSpace::Func();			//использовать функцию описанную в пространстве имен
using namespace NameSpace;	//позволить использовать аттрибуты пространства имен без указания ::
Внутри пространства имен также можно объявить пространство имен, доступ к нему осуществляется через ::




<m>[C++] ENUM</m>
<b>enum</b> - перечисление логически связанных констант
enum State
{
	OFF,	// = 0
	ON		// = 1
};
<b>или</b>
enum State
{
	State1 = -1,
	State2 = 0,
	State3 = 1
};
State _State = State::OFF;	//объявление и инициализация переменной типа enum
По умолчанию перечисление начинается с 0
Последующее неприсвоенное перечисление на 1 больше предыдущего перечисления




<m>[C++] STRUCT / CLASS</m>
<b>struct</b> - структура данных с public полями и методами по умолчанию
<b>class</b> - структура данных с private полями и методами по умолчанию
<b>Объявление Структуры</b>
struct Struct
{
	struct InternalStruct {int X, Y;} _InternalStruct;
	int A;
	string Text;
	void Func1() {...}
};
Поля структуры могут иметь любой тип, кроме типа этой же структуры
Поля могут быть жестко инициализированы: int A = 1;
<b>Объявление структурной Переменной</b>
Struct _Struct;
Struct _Struct {{1, 1}, 1, ""};
Struct Struct1 = Struct2;
Struct _Struct[10];
vector&lt;Struct&gt; V;
<b>Обращение к Полям и Вызов Методов Структуры</b>
_Struct.A = 1;
_Struct._InternalStruct.X = 1;
V[0].Text = "";
_Struct.Func1();




<m>[C++] TEMPLATE&lt;TYPENAME T&gt;</m>
<b>template&lt;typename T&gt;</b> - обощенный тип
Класс может работать с абсолютно любым типом данных
template&lt;typename T1, typename T2&gt;
class MyClass
{
	T1 Value1;
	T2 Value2;
public:
	MyClass(T1 Value1, T2 Value2)
	{
		this-&gt;Value1 = Value1;
		this-&gt;Value2 = Value2;
	}
};
MyClass&lt;int, double&gt; MC(A, B);		//t1 - int; t2 - double




<m>[C++] THREAD</m>
#include &lt;thread&gt;									//подключить заголовочный файл &lt;thread&gt;
this_thread::get_id();								//вернуть идентификатор текущего потока
this_thread::sleep_for(chrono::milliseconds(1000));	//остановить работу текущего потока на определенное время
<b>Методы Thread</b>
thread Th(Func);				//конструктор потока [принимает имя функции; выполняется параллельно]
thread Th(Func, A, B);			//конструктор потока [поток с параметрами; выполняется параллельно]
thread Th(this-&gt;Func);			//конструктор потока [вызов другого метода этого же класса; выполняется параллельно]
thread Th(&MyClass::Func, &MC);	//конструктор потока [или thread th([&mc]() {mc.func();}); &mc - изменять объект класса myclass]
Th.join();						//дождаться завершение потока [вызывать в момент, где нужно дождаться выполнения этого потока]
Th.detach();					//разорвать связь между объектом th и потоком [программа не станет дожидаться завершения потока]




<m>[C++] MUTEX / LOCK_GUARD / UNIQUE_LOCK</m>
time_point&lt;steady_clock&gt; TP = high_resolution_clock::now();	//инициализировать текущее время на этом этапе кода при выполнении
duration&lt;float&gt; Duration = TP2 - TP1;						//инициализировать разницу во времени между tp1 и tp2
Duration.count();											//вернуть время в секундах
<b>mutex</b> - не разрешает остальным потокам обращаться к ресурсу и работать с ним, если этот ресурс уже занят другим потоком
#include &lt;mutex&gt;						//подключить заголовочный файл &lt;mutex&gt;
mutex Mtx;								//объявить mutex
Mtx.lock();								//разрешить доступ к участку кода только по одному потоку
Mtx.unlock();							//разрешить доступ к участку кода для всех потоков
lock_guard&lt;mutex&gt; LG(Mtx);				//объявить lock_guard; разр доступ к участ кода только по одному потоку [до } или return]
unique_lock&lt;mutex&gt; UL(Mtx);				//объявить unique_lock; в конструкторе вызван lock()
unique_lock&lt;mutex&gt; UL(Mtx, defer_lock);	//объявить unique_lock; в конструкторе не будет вызван lock()
UL.lock();								//разрешить доступ к участку кода только по одному потоку
UL.unlock();							//разрешить доступ к участку кода для всех потоков
В деструкторе unique_lock будет вызван unlock(), если сам метод не был вызван в участке кода до } или return
Дестркутор lock_guard и unique_lock вызывается во время удаления самого объекта [перед } или return]




<m>[C++] TRY / CATCH</m>
<b>try catch</b> - блок работы с исключениями
<b>Пользовательский Exception</b>
class _exception : public exception
{
	int State;
public:
	_exception(const char* Msg, int State) : exception(Msg) {this-&gt;State = State;}	//переопределить конструктор
	int GetState() {return State;}													//вернуть состояние
};
<b>Броски Исключений</b>
throw _exception("msg _exception", Value);	//бросить _exception
throw exception("msg exception");			//бросить exception
throw "msg char*";							//бросить char*
throw Value;								//бросить значение
<b>Try / Catch Блок</b>
try
{
	//расположение исключений [может быть функция с исключениями]
}
catch (_exception& Ex) {cout &lt;&lt; Ex.what() &lt;&lt; Ex.GetState();}	//поймать _exception [обязательно перед exception]
catch (const exception& Ex) {cout &lt;&lt; Ex.what();}				//поймать exception
catch (const char* Ex) {cout &lt;&lt; Ex;}							//поймать char*
catch (...) {cout &lt;&lt; "msg last";}								//поймать неопределенный тип [обязательно последним]
</div>
</body>
</html>