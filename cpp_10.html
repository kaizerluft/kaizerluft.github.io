<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<title>10 C++ ALGORITHM +LAMBDA</title>
	<link href="style.css" rel="stylesheet" type="text/css">
</head>
<body>
	<div class="menu"></div>
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<div class="text">
		<br>
		<br>
		<mark>10 C++ ALGORITHM +LAMBDA</mark><br>
		<br>
		<br>
		Большинство из этих алгоритмов принимают два итератора (It1 и It2), т. е. алгоритм работает с элементами контейнера от It1 включительно до It2 невключительно<br>
		Если под It1 используется метод begin(), а под It2 метод end(), то алгоритм применяется ко всему контейнеру<br>
		<br>
		<br>
		Большинство из этих методов способны возвращать true, если алгоритм выполнен успешно, или определенный итератор в случае изменения значений контейнера<br>
		<br>
		<br>
		<b>Лямбда функция</b> – безымянная локальная функция, которую можно создавать прямо внутри какого-либо выражения<br>
		<br>
		<br>
		<b>Объявление анонимной функции</b><br>
		<span class="code">[](){};</span><br>
		Где:<br>
		<span class="code">[]</span> – список внешних захватываемых объектов<br>
		<span class="code">()</span> – параметры анонимной функции<br>
		<span class="code">{}</span> – тело анонимной функции<br>
		<br>
		<br>
		<span class="code">auto F = [](){};</span> – присвоить переменной класс лямбда<br>
		<br>
		<br>
		<span class="code">[&X, &Y]</span> – передача внешних параметров по ссылке<br>
		<span class="code">[&]</span> – передача всех внешних параметров по ссылке<br>
		<br>
		<br>
		<b>Подключение заголовочного файла algorithm</b><br>
		<span class="code">#include &lt;algorithm&gt;</span><br>
		<br>
		<br>
		+inserter – возможность вставить элементы через методы:<br>
		1) <span class="code">inserter(Container, It)</span><br>
		2) <span class="code">front_inserter(Container)</span><br>
		3) <span class="code">back_inserter(Container)</span><br>
		Condition – булевская или анонимная функция (например, <span class="code">[](int El){return El > 0;}</span>)<br>
		<br>
		<br>
		<b>Методы algorithm</b><br>
		<table width="100%">
			<tr>
				<td><span class="code">copy(It1, It2, It3)</span></td>
				<td>– копировать элементы (+inserter)</td>
			</tr>
			<tr>
				<td><span class="code">copy_if(It1, It2, It3, Condition)</span></td>
				<td>– копировать элементы с условием (+inserter)</td>
			</tr>
			<tr>
				<td><span class="code">move(It1, It2, It3)</span></td>
				<td>– вставить элементы с замещением (+inserter)</td>
			</tr>
			<tr>
				<td><span class="code">remove(It1, It2, Value)</span></td>
				<td>– убрать элементы за возвращаемый итератор</td>
			</tr>
			<tr>
				<td><span class="code">remove_if(It1, It2, Condition)</span></td>
				<td>– убрать элементы за возвращаемый итератор c условием</td>
			</tr>
			<tr>
				<td><span class="code">unique(It1, It2)</span></td>
				<td>– убрать неуникальные элементы за возвращаемый итератор</td>
			</tr>
			<tr>
				<td><span class="code">unique_copy(It1, It2, It3)</span></td>
				<td>– копировать уникальные элементы (+inserter)</td>
			</tr>
			<tr>
				<td><span class="code">min_element(It1, It2)</span></td>
				<td>– вернуть минимальный элемент</td>
			</tr>
			<tr>
				<td><span class="code">max_element(It1, It2)</span></td>
				<td>– вернуть максимальный элемент</td>
			</tr>
			<tr>
				<td><span class="code">minmax_element(It1, It2)</span></td>
				<td>– вернуть пару из минимального и максимального элемента</td>
			</tr>
			<tr>
				<td><span class="code">count(It1, It2, Value)</span></td>
				<td>– вернуть кольчество элементов</td>
			</tr>
			<tr>
				<td><span class="code">count_if(It1, It2, Condition)</span></td>
				<td>– вернуть количество элементов с условием</td>
			</tr>
			<tr>
				<td><span class="code">equal(It1, It2, It3, It4)</span></td>
				<td>– true, если диапазоны итераторов содержат одинаковые элементы</td>
			</tr>
			<tr>
				<td><span class="code">sort(It1, It2)</span></td>
				<td>– сортировать  элементы по возрастанию</td>
			</tr>
			<tr>
				<td><span class="code">random_shuffle(It1, It2)</span></td>
				<td>– переставить элементы в случайном порядке</td>
			</tr>
			<tr>
				<td><span class="code">rotate(It1, It1 + N, It2)</span></td>
				<td>– сместить элементы на N</td>
			</tr>
			<tr>
				<td><span class="code">rotate_copy(It1, It1 + N, It2, It3)</span></td>
				<td>– сместить элементы на N с копированием (+inserter)</td>
			</tr>
			<tr>
				<td><span class="code">reverse(It1, It2)</span></td>
				<td>– развернуть элементы в обратном порядке</td>
			</tr>
			<tr>
				<td><span class="code">binary_search(It1, It2, Value)</span></td>
				<td>– true, если элемент присутствует (контейнер упорядочен)</td>
			</tr>
			<tr>
				<td><span class="code">find(It1, It2, Value)</span></td>
				<td>– вернуть итератор встречи элемента</td>
			</tr>
			<tr>
				<td><span class="code">find_if(it1, it2, Condition)</span></td>
				<td>– вернуть итератор встречи элемента по условию</td>
			</tr>
			<tr>
				<td><span class="code">lower_bound(It1, It2, Value)</span></td>
				<td>– вернуть итератор встречи элемента большее или равное значению</td>
			</tr>
			<tr>
				<td><span class="code">upper_bound(It1, It2, Value)</span></td>
				<td>– вернуть итератор встречи элемента большее значению</td>
			</tr>
		</table>
	</div>
</body>